[
    {
        "qText": "Oca-24",
        "qNum": 45292,
        "qElemNumber": 14,
        "qState": "X"
    },
    {
        "qText": "1.11",
        "qNum": 1.1058333333333332,
        "qElemNumber": 0,
        "qState": "L"
    },
    {
        "qText": "6046.0265930258",
        "qNum": 6046.026593025833,
        "qElemNumber": 0,
        "qState": "L"
    },
    {
        "qText": "1.05",
        "qNum": 1.05,
        "qElemNumber": 0,
        "qState": "L"
    }
]

    const drawComboChart = () => {

        if (dataBar.length === 0 && dataLine.length === 0) return;


        const svg = d3.select(svgRef.current)

        svg.selectAll("*").remove()



        // Margin ve boyutlar
        const margin = { top: 20, right: 80, bottom: 60, left: 80 }; // Sağda ve solda daha fazla boşluk
        const width = svgSize.width - margin.left - margin.right;
        const height = svgSize.height - margin.top - margin.bottom;

        svg
            .attr("width", svgSize.width)
            .attr("height", svgSize.height)
            .append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);


        // Zaman verisini parse etmek için yardımcı fonksiyon
        const parseDate = d3.timeParse("%b-%y");  // "%b-%y" Jan-23 gibi formatları işlemek için


        // Ortak X eksenis
        const x = d3.scaleBand()
            .domain(dataBar.map(d => parseDate(translateMonthToEnglish(d.date))))  // Her bir tarihi domena ekliyoruz
            .range([0, width])  // Eksenin genişliği
            .padding(0.5);  // Barlar arasına boşluk bırakıyoruz

        // Y eksenleri
        const yBar = d3.scaleLinear()
            .domain([0, d3.max(dataBar, d => d.value)])
            .nice()
            .range([height, 0]);

        const yLine1 = d3.scaleLinear()
            .domain([0, d3.max(dataLine, d => d.value1)])
            .nice()
            .range([height, 0]);

        const yLine2 = d3.scaleLinear()
            .domain([0, d3.max(dataLine, d => d.value2)])
            .nice()
            .range([height, 0]);

        const chartGroup = svg
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);
        // X ekseni çizimi
        const xAxis = d3.axisBottom(x)
            .tickValues(   // Her bir tarih sadece bir kez görünsün
                Array.from(new Set(dataBar.map(d => {
                    const translatedDate = translateMonthToEnglish(d.date);
                    const parsedDate = parseDate(translatedDate);
                    return parsedDate ? parsedDate.getTime() : null;  // null kontrolü ekleniyor
                })))
                    .filter(d => d !== null)  // null değerleri atıyoruz
                    .map(d => new Date(d))  // Set içerisindeki tarihleri tekrar Date objelerine dönüştürüyoruz
            )
            .tickFormat(d3.timeFormat("%b %y"))  // Ay ve yıl formatında gösterecek şekilde düzenliyoruz
            .tickSize(0);


        chartGroup.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(xAxis)


        // Y eksenleri
        chartGroup.append('g')
            .attr('class', 'y-axis-left')
            .call(d3.axisLeft(yBar));

        // Sağ Y ekseni (line chart için)
        chartGroup.append('g')
            .attr('class', 'y-axis-right')
            .attr('transform', `translate(${width}, 0)`)
            .call(d3.axisRight(yLine1));

        // Bar Chart çizimi
        chartGroup.selectAll('.bar')
            .data(dataBar)
            .enter()
            .append('rect')
            .attr('class', 'bar')
            .attr('x', (d) => x(parseDate(translateMonthToEnglish(d.date)))) // X koordinatı için bandwidth kullanıyoruz
            .attr('y', d => yBar(d.value))
            .attr('width', x.bandwidth()) // Bar genişliğini bandwith ile alıyoruz
            .attr('height', d => height - yBar(d.value))
            .attr('fill', '#dc9465');

        // Line Chart çizimi
        const line1 = d3.line()
            .x(d => x(parseDate(translateMonthToEnglish(d.date))))
            .y(d => yLine1(d.value1));

        const line2 = d3.line()
            .x(d => x(parseDate(translateMonthToEnglish(d.date))))
            .y(d => yLine2(d.value2));

        chartGroup.append('path')
            .data([dataLine])
            .attr('class', 'line1')
            .attr('d', line1)
            .attr('fill', 'none')
            .attr('stroke', '#2b85c9') // mavi line
            .attr('stroke-width', 2);

        chartGroup.append('path')
            .data([dataLine])
            .attr('class', 'line2')
            .attr('d', line2)
            .attr('fill', 'none')
            .attr('stroke', '#a1c789') // yeşil line
            .attr('stroke-width', 2);

            chartGroup.selectAll('.circle1')
            .data(dataLine)
            .enter()
            .append('circle')
            .attr('class', 'circle1')
            .attr('cx', d => x(parseDate(translateMonthToEnglish(d.date))))
            .attr('cy', d => yLine1(d.value1))
            .attr('r', 5)
            .attr('fill', 'none')  // İçi boş 
            .attr('stroke', '#2b85c9')  // Kenarlık rengi mavi 
            .attr('stroke-width', 1.5);

            chartGroup.selectAll('.label1')
            .data(dataLine)
            .enter()
            .append('text')
            .attr('class', 'label1')
            .attr('x', d => x(parseDate(translateMonthToEnglish(d.date))))
            // .attr('y', d => y(d.value1) +20)
            .attr('y', d => {
                if(d.value1 == d.value2){
                    return yLine1(d.value1) - 10;
                }
                //d.value1, d.value2 değerine göre circle üzerindeki text'lerin konum ayarlaması yapılır.
                return d.value1 > d.value2 ? yLine1(d.value1) - 10 : yLine1(d.value1) + 20;
            })
            .attr('text-anchor', 'middle')
            .style('fill', '#2b85c9')
            .style('font-size', '10px')
            .text(d => (d.value1) + '%');

            chartGroup.selectAll('.circle2')
            .data(dataLine)
            .enter()
            .append('circle')
            .attr('class', 'circle2')
            .attr('cx', d => x(parseDate(translateMonthToEnglish(d.date))))
            .attr('cy', d => yLine2(d.value2))
            .attr('r', 5)
            .attr('fill', 'none')  // İçi boş 
            .attr('stroke', '#a1c789')  // Kenarlık rengi yeşil 
            .attr('stroke-width', 1.5);

            chartGroup.selectAll('.label2')
            .data(dataLine)
            .enter()
            .append('text')
            .attr('class', 'label2')
            .attr('x', d => x(parseDate(translateMonthToEnglish(d.date))))
            // .attr('y', d => y(d.value2) - 10)
            .attr('y', d => {
                //d.value1, d.value2 değerine göre circle üzerindeki text'lerin konum ayarlaması yapılır.
                return d.value2 > d.value1 ? yLine2(d.value2) - 10 : yLine2(d.value2) + 20;
            })
            .attr('text-anchor', 'middle')
            .style('fill', '#a1c789')
            .style('font-size', '10px')
            .text(d => (d.value2) + '%');

    }
