import { useRef, useEffect, useState } from 'react';
import * as d3 from 'd3';
import { getObjectData } from '@/util/qlikConnection';

export default function LineChart({ app, objectId , legendText }) {
    const svgRef = useRef(null);    
    const chartContainerRef = useRef(null);
    const [data, setData] = useState([]);
    const [svgSize, setSvgSize] = useState({ width: 0, height: 0 });
    
    // Türkçe ayları İngilizce'ye dönüştüren  fonksiyon
    const translateMonthToEnglish = (dateString) => {
        const months = {
            'Oca': 'Jan',
            'Şub': 'Feb',
            'Mar': 'Mar',
            'Nis': 'Apr',
            'May': 'May',
            'Haz': 'Jun',
            'Tem': 'Jul',
            'Ağu': 'Aug',
            'Eyl': 'Sep',
            'Eki': 'Oct',
            'Kas': 'Nov',
            'Ara': 'Dec'
        };

        // Türkçe ayları İngilizce'ye dönüştürme
        const parts = dateString.split('-');
        if (parts.length === 2) {
            const month = parts[0];
            const year = parts[1];
            const englishMonth = months[month];

            if (englishMonth) {
                return `${englishMonth}-${year}`;
            }
        }
        return dateString;  // Eğer dönüştürülmüş format yoksa, orijinal formatı döndür
    };
    
    useEffect(() => {
        function renderLineObject(objectId) {
  
            if (app) {
                getObjectData(app, objectId).then((response) => {
                    const incomingData = response.map(item => ({
                        date: item[0].qText,
                        value1: parseFloat((item[1].qText).replace('%', '').trim()),
                        value2: parseFloat((item[2].qText).replace('%', '').trim()),
                        
                    }));
                    console.log(incomingData)
                    setData(incomingData)
                });
            } else {
                console.error('Qlik Sense app is not loaded yet');
            }
        }

        renderLineObject(objectId);
    }, [app, objectId]);
    const updateDimensions = () => {
        if (chartContainerRef.current) {
          setSvgSize({
            width: chartContainerRef.current.offsetWidth, // div'in genişliği
            height: chartContainerRef.current.offsetHeight, // div'in yüksekliği
          });
        }
      };
    
      // Responsive tasarım için boyutları günceller
      useEffect(() => {
        updateDimensions(); // İlk boyutlandırmayı yap
        window.addEventListener('resize', updateDimensions); // Pencere boyutu değiştiğinde boyutları güncelle
    
        return () => {
          window.removeEventListener('resize', updateDimensions); // Temizleme işlemi
        };
      }, []);
      const drawLineChart = () => {
        if (data.length === 0) return;
            const svg = d3.select(svgRef.current);
            svg.selectAll('*').remove();

            const margin = { top: 30, right: 20, bottom: 0, left: 10 };
            const width = svgSize.width - margin.left - margin.right;
            const height = svgSize.height - margin.top - margin.bottom;
            svg
            .attr("width", width)
            .attr("height", height);
            
            const g = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);
    
            // Tarih formatını uygun bir Date objesine dönüştüren parse fonksiyonu
            const parseDate = d3.timeParse("%b-%y");  // "%b-%y" Jan-23 gibi formatları işlemek için
    
            // Y ekseninin üst sınırını biraz genişletmek için maksimum değerin üzerine ekleme yapalım
            const maxValue = d3.max(data, d => Math.max(d.value1, d.value2));
            const yMax = Math.ceil(maxValue / 20) * 20 + 20;
    
            const x = d3.scaleTime()
                .domain(d3.extent(data, d => parseDate(translateMonthToEnglish(d.date))))  // Türkçe tarihleri İngilizce'ye çevirip parse ediyoruz
                .range([15, width]);
    
            const y = d3.scaleLinear()
                .domain([0, yMax])
                .nice()
                .range([height, 0]);
    
            const xAxis = d3.axisBottom(x)
                .tickValues(   // Her bir tarih sadece bir kez görünsün
                    Array.from(new Set(data.map(d => {
                        const translatedDate = translateMonthToEnglish(d.date);
                        const parsedDate = parseDate(translatedDate);
                        return parsedDate ? parsedDate.getTime() : null;  // null kontrolü ekleniyor
                    })))
                        .filter(d => d !== null)  // null değerleri atıyoruz
                        .map(d => new Date(d))  // Set içerisindeki tarihleri tekrar Date objelerine dönüştürüyoruz
                )
                .tickFormat(d3.timeFormat("%b %y"))  // Ay ve yıl formatında gösterecek şekilde düzenliyoruz
                .tickSize(0);
    
            // const yAxis = d3.axisLeft(y)
            //     .tickValues(d3.range(0, yMax, 20))
            //     .tickSize(-width);
    
            const yAxis = d3.axisLeft(y)
                .tickValues([Math.floor(yMax / 2)])  // Y ekseninde sadece ortadaki değeri göstereceğiz
                .tickSize(-width)  // Bu, Y eksenindeki çizgiyi yatay olarak çizecek
                .tickFormat(d3.format('d'));
    
    
    
            g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0, ${height})`)
                .call(xAxis)
                .selectAll('.domain')
                .remove();;
    
            g.append('g')
                .attr('class', 'y-axis')
                .call(yAxis)
                .selectAll('.domain')
                .remove();
    
            // Y eksenindeki metinleri gizlemek için
            g.selectAll('.y-axis .tick text')
                .style('display', 'none');
    
            g.selectAll('.y-axis .tick line')
                .style('stroke', '#d3d3d3')
                .style('stroke-width', 1);
    
            // X eksenini yatay olarak genişletmek için yeni bir path ekleme
            g.append('path')
                .attr('class', 'x-axis-line')
                .attr('d', `M0,${height} H${width}`)  // Bu, çizgiyi 0'dan width'e kadar uzatır
                .attr('stroke', '#d3d3d3')
                .attr('stroke-width', 1);
    
            const line1 = d3.line()
                .x(d => x(parseDate(translateMonthToEnglish(d.date))))  // Tarihleri parse ediyoruz
                .y(d => y(d.value1));
    
            const line2 = d3.line()
                .x(d => x(parseDate(translateMonthToEnglish(d.date))))  // Tarihleri parse ediyoruz
                .y(d => y(d.value2));
    
            g.append('path')
                .data([data])
                .attr('class', 'line')
                .attr('d', line1)
                .attr('stroke', '#2b85c9')
                .attr('fill', 'none')
                .attr('stroke-width', 2);
    
            g.append('path')
                .data([data])
                .attr('class', 'line')
                .attr('d', line2)
                .attr('stroke', '#a1c789')
                .attr('fill', 'none')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '1,2')
    
            g.selectAll('.circle1')
                .data(data)
                .enter()
                .append('circle')
                .attr('class', 'circle1')
                .attr('cx', d => x(parseDate(translateMonthToEnglish(d.date))))
                .attr('cy', d => y(d.value1))
                .attr('r', 5)
                .attr('fill', 'none')  // İçi boş 
                .attr('stroke', '#2b85c9')  // Kenarlık rengi mavi 
                .attr('stroke-width', 1.5);
    
            g.selectAll('.label1')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'label1')
                .attr('x', d => x(parseDate(translateMonthToEnglish(d.date))))
                .attr('y', d => y(d.value1) - 10)
                .attr('text-anchor', 'middle')
                .style('fill', '#2b85c9')
                .style('font-size', '10px')
                .text(d => (d.value1) + '%');
    
            g.selectAll('.circle2')
                .data(data)
                .enter()
                .append('circle')
                .attr('class', 'circle2')
                .attr('cx', d => x(parseDate(translateMonthToEnglish(d.date))))
                .attr('cy', d => y(d.value2))
                .attr('r', 5)
                .attr('fill', 'none')  // İçi boş 
                .attr('stroke', '#a1c789')  // Kenarlık rengi mavi 
                .attr('stroke-width', 1.5);
    
            g.selectAll('.label2')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'label2')
                .attr('x', d => x(parseDate(translateMonthToEnglish(d.date))))
                .attr('y', d => y(d.value2) + 20)
                .attr('text-anchor', 'middle')
                .style('fill', '#a1c789')
                .style('font-size', '10px')
                .text(d => (d.value2) + '%');
    
            // const legend = g.append('g')
            //     .attr('transform', `translate(${width / 2 - 80}, ${height + 40})`);
    
            const legend = g.append('g')
                .attr('transform', `translate(${width - 120}, -20)`);  // Sağ üst köşeye yerleştiriyoruz
    
            legend.append('rect')
                .attr('x', 0)
                .attr('y', -10)
                .attr('width', 10)
                .attr('height', 10)
                .attr('rx',2)
                .attr('ry',2)
                .attr('fill', '#2b85c9');
    
            legend.append('text')
                .attr('x', 15)
                .attr('y', 0)
                .style('fill', '#2b85c9')
                .style('font-size', '12px')
                .text(legendText);
    
            legend.append('rect')
                .attr('x', 65)
                .attr('y', -10)
                .attr('width', 10)
                .attr('height', 10)
                .attr('rx',2)
                .attr('ry',2)
                .attr('fill', '#a1c789');
    
            legend.append('text')
                .attr('x', 80)
                .attr('y', 0)
                .style('fill', '#a1c789')
                .style('font-size', '12px')
                .text('Ortalama');
      
        
    };
    useEffect(() => {
        if (svgSize.width > 0 && svgSize.height > 0) {
            drawLineChart();
        }
      }, [data, svgSize]);
    // useEffect(() => {
       

    //     drawLineChart();
    // }, [legendText, data]);

    return (
        <div ref={chartContainerRef} style={{ width: '100%', height: '300px'}}>
        <svg ref={svgRef} style={{ width: '100%' }}></svg>
      </div>
    )
}
  <div className="card">
              <div className="card-title">Bireysel</div>
              <div className="card-content">
                <LineChart app={app} objectId={"pQVjzMC"} legendText={"Bireysel"} />
                <BubbleChart app={app} objectId={"rhSJF"}></BubbleChart>
                <div className="d-flex justify-content-around column-gap-5 mb-1">
                  <HighLowTable app={app} objectId={"naXuP"} level={"up"} />
                  <HighLowTable app={app} objectId={"MSRHmHP"} level={"down"} />
                </div>
              </div>
            </div>
